<!DOCTYPE html>
<html lang="en"><head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<title>PowerBlocks</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	
	<script src="util.js"></script>

	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		#help-btn {
			border-radius: 50%;
			width: 10vw;
			height: 10vw;
			position: absolute;
			bottom: 5vw;
			right: 5vw;
			font-size: 7vw;
			line-height: 10vw;
			background-color: black;
			color: white;
			text-align: center;
		}
		
		#help-div {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			
			box-sizing: border-box;
			
			padding: 2em;
			
			background-color: white;
			
			display: none;
			
			z-index: 100;
			
			overflow-y: scroll;
							
			font-size: 2vw;
			line-height: 2.2vw;
		}
		
		#help-close-btn {
			position: absolute;
			right: 2vw;
		}
		
		#help-nav {
			font-size: 5vw;
		}
		
		.help-type-btn {
			border: 0.1em solid black;
			border-bottom-width: 0;
			display: inline-block;
			padding: 0.5em;
		}
		
		#help-desktop-div {
			display: block;
		}
	</style>
</head>
<body>

	<script src="THREE/three.js"></script>
	<script src="THREE/stats.js"></script>
	
	<script>
	
	if ( !window.performance ) { performance = { now: Date.now }; }
	
	var gPlaying = true;
			
	var kBlockSize = 10;
		
		var axes = [ "x", "y", "z" ];
		var oAxes = [ [ "y", "z" ], [ "x", "z" ], [ "x", "y" ] ];
	
	var blocksToSkin = {};
	
	
	
		function blockClass( x, y, z, textureIndex, guts )
		{
			this.aPirate = false;
			
			var ox = x;
			var oy = y;
			var oz = z;
			
			var blockLoc = [x, y, z].toString(); //[ ox, oy, oz ].toString();
			
			//console.log( "placing block at ", blockLoc );
			
			rootBlock.blocks[ blockLoc ] = this;
			
			//console.log( "world: ", rootBlock.blocks );
			
			this.bposition = new THREE.Vector3( x, y, z );
			
			this.positionString = blockLoc;
			
			x *= kBlockSize;
			y *= kBlockSize;
			z *= kBlockSize;

			// flat shape with texture
			// note: default UVs generated by ShapeGemoetry are simply the x- and y-coordinates of the vertices

			var geometry = new THREE.BoxGeometry( kBlockSize, kBlockSize, kBlockSize );
			
			//geometry.translate( kBlockSize / 2, kBlockSize / 2 , kBlockSize / 2 );
			
			if ( !textureIndex ) textureIndex = currentTextureID;
			this.textureIndex = textureIndex;
			var texture = textures[ textureIndex ];
			
			if ( texture )
				this.material = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } );
			else
			{
				this.material = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x999999 } );
				if ( !blocksToSkin[ textureIndex ] )
					blocksToSkin[ textureIndex ] = [ this ]
				else
					blocksToSkin[ textureIndex ].push( this );
			}
			
			// using one material for all faces means alter one face, alter them all
			
			//alert( "test" );
			var cmesh = new THREE.Mesh( geometry, this.material );
			this.mesh = cmesh;
			this.mesh.owner = this;
			cmesh.position.set( x, y, z );
			group.add( cmesh );
			//alert( "test out" );
			
			for ( var i in guts )
			{
				console.log( "add guts ", i, guts[i] );
				var g = "(" + guts[i] + ")";
				console.log( g  );
				this[i] = eval( g );
			}
			
			Object.defineProperty( this, "getFunctions",
				{
					enumerable: false,
					value: 
						function ()
						{
							var r = {};
							for ( var i in this )
							{
								if ( this[i] instanceof Function )
									r[i] = this[i].toString();
							}
							return r;
						}
					} );
			
			Object.defineProperty( this, "texture",
				{
					enumerable: true,
					get: 
						function ()
						{
							return this.textureIndex;
						},
					set:
						function (v)
						{
							this.material.map = textures[v];
							this.textureIndex = v;
							return v;
						}
					} );
					
			
			
			// using one material for all faces means alter one face, alter them all
			this.Hmaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0xff0000, wireframe: true, wireframeLinewidth: 5 } );
			
			var hScaleFactor = 1;
			var nSize = kBlockSize * hScaleFactor;
			this.Hgeometry = new THREE.BoxGeometry( nSize, nSize, nSize );
			this.highlightMesh = new THREE.Mesh( this.Hgeometry, this.Hmaterial );
			this.highlightMesh.position.set( x, y, z );
			
			Object.defineProperty( this, "highlight",
				{
					enumerable: true,
					get: 
						function ()
						{
							return this.highlightVal;
						},
					set:
						function (v)
						{
							if ( v )
								scene.add( this.highlightMesh );
							else
								scene.remove( this.highlightMesh );
							
							this.highlightVal = v;
						}
					} );
		}
		blockClass.prototype.action =
			function ()
			{
				console.log( "lights! camera! action!" );
			};
		blockClass.prototype.remove =
			function ()
			{
				rootBlock.blocks[ this.positionString ] = null;
				group.remove( this.mesh );
				var i = physObjs.findIndex( function ( el, ind, ar ) { return el == this; } );
				if ( i >= 0 )
					physObjs.splice( i, 1 );
			};
		blockClass.prototype.move =
			function ( x, y, z )
			{
				//console.log( "move", x, y, z );
				
				if ( !x ) x = 0;
				if ( !y ) y = 0;
				if ( !z ) z = 0;
				
				//console.log( "move1", this.mesh.position.x, this.mesh.position.y, this.mesh.position.z );
				this.mesh.position.x += (+x);
				this.mesh.position.y += (+y);
				this.mesh.position.z += (+z);
				
				this.highlightMesh.position.x += (+x);
				this.highlightMesh.position.y += (+y);
				this.highlightMesh.position.z += (+z);
				//console.log( "move2", this.mesh.position.x, this.mesh.position.y, this.mesh.position.z );
				
				var nx = Math.round( this.mesh.position.x / 10 );
				var ny = Math.round( this.mesh.position.y / 10 );
				var nz = Math.round( this.mesh.position.z / 10 );
				
				var newPos = [ nx, ny, nz ].toString();
				
				this.cposition = {};
				
				for ( var i = 0; i < 3; i++ )
				{
					var axis = axes[i];
					var c = this.mesh.position[ axis ] / 10;
					
					//console.log( "pos", this.mesh.position );
					//console.log( "c", c, axis )
					
					if ( Math.round( c ) < c )
					{
						this.cposition[ axis ] = [ Math.round( c ), Math.round( c ) + 1 ];
					}
					else if ( Math.round( c ) > c )
					{
						this.cposition[ axis ] = [ Math.round( c ), Math.round( c ) - 1 ];
					}
					else
						this.cposition[ axis ] = [ Math.round( c ) ];
				}
				
				if ( newPos != this.positionString )
				{
					//console.log( "delta", newPos, this.positionString );
					rootBlock.blocks[ this.positionString ] = null;
					this.positionString = newPos;
					rootBlock.blocks[ newPos ] = this;
					
					this.bposition = new THREE.Vector3( nx, ny, nz );
				}
			};
		blockClass.prototype.collision =
			function ( obj, axis )
			{
				//gPlaying = false;
				//console.log( "collision with" );
				//console.log( obj );
				
				// immediate stop
				this[ 'V' + axis ] = 0;
				this.atRest[ axis ] = true;
				
				// bounce:
				//this[ 'V' + axis ] *= -0.8;
				//if ( this[ 'V' + axis ] <= 5 ) { this[ 'V' + axis ] = 0; this.atRest[ axis ] = true; }
			};
	
	/** physics **/
	
	var physObjs = [];
	var lastTime;
	
	var kFrameRate = 20;
	var kMS = 1000 / kFrameRate;
	
	var kMaxSteps = 2;
	
	var kGravity = -50;
	
	function physicsCallback()
	{
		var now = performance.now();
		
		if ( ! lastTime )
		{
			lastTime = now - kMS;
			var mult = 1;
		}
		else
			var mult = Math.floor( (now - lastTime) / kMS );
		
		//console.log( "mult", mult );
		
		if ( mult == 0 ) return;
		
		mult = Math.min( mult, kMaxSteps );
		
		var tdelta = (mult * kMS) / 1000;
		
		var tleft = tdelta;
		
		//console.log( mult, tdelta );
		
		lastTime = now - ((now - lastTime) - (mult * kMS));
		
		/*	calculate trajectory
			divide by kBoxSize
			sort / find max/min
			loop from ceil(min) to floor(max) */
			
		for ( var i = 0; i < physObjs.length; i++ ) //if ( physObjs.length > 0 )
		{
			var cobj = physObjs[i].owner;
			cobj.atRest = {};
			//if ( cobj.atRest.y ) continue;
			cobj.Vy += kGravity * tleft;
		}
		
		var p0;
		do
		{
			//console.log( "tleft", tleft );
			
			var times = [];
			for ( var i = 0; i < physObjs.length; i++ ) //if ( physObjs.length > 0 )
			{
				var cobj = physObjs[i].owner;
			
				p0 = cobj.mesh.position.clone();
				var cp = p0.clone();
			
				//console.log( "p0", p0 );
			
				/* move objects */
				
				cp.x += (cobj.Vx * tleft);
				cp.y += (cobj.Vy * tleft);
				cp.z += (cobj.Vz * tleft);
				
				//console.log( "X", p0.x, cp.x );
			
				//console.log( "x", Math.ceil( p0.x / 10 ), Math.floor( cp.x / 10 ) );
			
				//console.log( "cp", cp );
				
				// calc Y collisions
			
				//console.log( "cpos", cobj.cposition.x.length, cobj.cposition.z.length, cobj.cposition )
			
				for ( var a = 0; a < 3; a++ )
				{
					var axis = axes[ a ];
					
					if ( cobj.atRest[ axis ] ) continue;
				
					var oa1 = oAxes[ a ][0];
					var oa2 = oAxes[ a ][1];
					
					//console.log( "oa", oa1, oa2 );
					
					var Va = cobj[ 'V' + axis ];
					
					if ( Va ) // Va != 0
					{
						var sgn = Math.sign( Va )
						if ( Va < 0 )
						{
							var startFnc = Math.floor;
							var cmpFnc = function ( l, r ) { return l >= Math.ceil( r ); };
						}
						else // Va > 0
						{
							var startFnc = Math.ceil;
							var cmpFnc = function ( l, r ) { return l <= Math.floor( r ); };
						}
						
						for ( var xi = 0; xi < cobj.cposition[ oa1 ].length; xi++ )
						{
							for ( var zi = 0; zi < cobj.cposition[ oa2 ].length; zi++ )
							{
								for ( var yi = startFnc( p0[ axis ] / 10 );
										cmpFnc( yi, cp[ axis ] / 10 );
										yi += sgn )
								{
									var xiv = cobj.cposition[ oa1 ][xi];
									var ziv = cobj.cposition[ oa2 ][zi];
									
									var npo = {};
									npo[ axis ] = yi + sgn;
									npo[ oa1 ] = xiv;
									npo[ oa2 ] = ziv;
								
									//console.log( "x", npo.x, "y", npo.y, "z", npo.z );
					
									var colblock = rootBlock.blocks[ [ npo.x, npo.y, npo.z ].toString() ];
					
									//console.log( colblock );
					
									if ( colblock )
									{
										var t = (yi * 10 - p0[ axis ]) / Va;
										times.push( { time: t, axis: axis, object: cobj, target: colblock } );
									} // colblock
								} // for yi
							} // for zi
						} // for xi
					} // if Va
				} // for axis
			} // for objs
			
			if ( times.length > 0 )
			{
				times.sort(
					function ( a, b )
					{
						return a.time - b.time;
					} );
				
				for ( var i = 0; i < physObjs.length; i++ )
				{
					var cobj = physObjs[i].owner;
					
					// this should maybe not be a loop
					for ( var a = 0; a < 3; a++ )
					{
						var axis = axes[ a ];
						
						var Va = cobj[ 'V' + axis ];
						
						var npo = { x: 0, y: 0, z: 0 };
						npo[ axis ] = Va * times[0].time;
						
						cobj.move( npo.x, npo.y, npo.z );
					}
				}
				//console.log( "proc", times[0] );
				times[0].object.collision( times[0].target, times[0].axis );
				tleft -= times[0].time;
			}
			
		}
		while ( times.length > 0 );
		
		if ( tleft )
		{
			for ( var i = 0; i < physObjs.length; i++ )
			{
				var cobj = physObjs[i].owner;
				
				// this should maybe not be a loop
				for ( var a = 0; a < 3; a++ )
				{
					var axis = axes[ a ];
					
					var Va = cobj[ 'V' + axis ];
					
					var npo = { x: 0, y: 0, z: 0 };
					npo[ axis ] = Va * tleft;
					
					cobj.move( npo.x, npo.y, npo.z );
				}
			}
		}
	}
	
	function makePhysTest( x, y, xv )
	{
		var geometry = new THREE.BoxGeometry( kBlockSize, kBlockSize, kBlockSize );
		
		// using one material for all faces means alter one face, alter them all
		var material = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x00ff00 } );
		
		var cmesh = (new blockClass( x ? x : 0, y ? y : 3, 0, -1 )).mesh;
		cmesh.material = material;
		
		//console.log( cmesh.owner );
		
		var o = cmesh.owner;
		o.Vx = xv ? xv : 0;
		o.Vy = 0;
		o.Vz = 0;
		
		o.atRest = {};
		
		cmesh.owner.move( 0,0,0 ); //2.5, 0, 0 );
		
		physObjs.push( cmesh );
	}
	
	function addPhysics( obj, vx, vy, vz )
	{
		var o = obj;
		o.Vx = vx ? vx : 0;
		o.Vy = vy ? vy : 0;
		o.Vz = vz ? vz : 0;
		
		o.atRest = {};
		
		obj.move( 0,0,0 );
		
		physObjs.push( obj.mesh );
	}
	
	/*************/
	
	
		
		var keysDown = {};
		
		function worldBlockClass ( x, y )
		{
			this.x = x;
			this.y = y;
			
			this.blocks = {};
		}

		var container, stats;

		var camera, scene, raycaster, renderer;

		var group;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;
		
		var targetXRotation = 0;
		var targetXRotationOnMouseDown = 0;

		var mouseDown = false;
		var mouseX = 0;
		var mouseXOnMouseDown = 0;
		var mouseY = 0;
		
		var mouseVY = 0, mouseVX = 0;
		
		var mouse = new THREE.Vector2(), INTERSECTED;
		var objectUnderMouse;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		
		var textures = [];
		
		var kTextureURL = "textures/block.jpg";
		
		var currentTextureID = 0;
		
		function loadTexture( textureURL, name )
		{
			//console.log( "load texture", textureURL );
			
			var pxtexture;
			
			var pat = /^https?:\/\//i;
			if ( pat.test(textureURL) )
			{
				console.log( "abs url", "getfile.php?url=" + encodeURIComponent( textureURL ) );
				
				var pxcan = document.createElement( "canvas" );
				pxcan.width = 256;
				pxcan.height = 256;
				var pxctx = pxcan.getContext( "2d" );
				var pximg = new Image();
				pximg.onload =
					function ()
					{
						pxctx.drawImage( pximg, 0, 0, 256, 256 );
					
						pxtexture = new THREE.Texture( pxcan );
						pxtexture.needsUpdate = true;
			
						if ( name )
							textures[ name ] = pxtexture;
						else
							textures.push( pxtexture );
					};
				pximg.src = "getfile.php?url=" + encodeURIComponent( textureURL );
			}
			else
			{
				/*pxtexture = THREE.ImageUtils.loadTexture( textureURL, null,
					function (x) { console.log( "texture onLoad", x ); },
					function (x) { console.log( "texture load error", x ); } );*/
					
				// instantiate a loader
				var loader = new THREE.TextureLoader();

				loader.crossOrigin = true;

				// load a resource
				loader.load(
					// resource URL
					textureURL,
					// Function when resource is loaded
					function ( texture )
					{
						// do something with the texture
						var n;
						if ( name )
						{
							textures[ name ] = texture;
							n = name;
						}
						else
						{
							textures.push( texture );
							n = textures.length - 1;
						}
						
						if ( blocksToSkin[ n ] )
						{
							for ( var i = 0; i < blocksToSkin[ n ].length; i++ )
								blocksToSkin[ n ][i].mesh.material = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } );
								
							blocksToSkin[ n ] = null;
						}
					},
					// Function called when download progresses
					function ( xhr ) {
						/*console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )*/;
					},
					// Function called when download errors
					function ( xhr ) {
						console.log( 'An error happened loading a texture' );
					}
				);
			}
		}
		
		var rootBlock = new worldBlockClass( 0, 0 );
		
		function getBlock( x, y, z ) { return rootBlock.blocks[ [ x, y, z ].toSrting() ]; }

		init();
		animate();
	
		placeBlock( -1, 0, 0 );
		//makePhysTest(0,15,0);
		makePhysTest(-2,5,5);
		//makePhysTest(3,9,-5);
		
		/*******/
		
		var sax = 1;
		var axl = 1000;
		
		var axgeometry = new THREE.Geometry();
		
		var axgeometryX = new THREE.BoxGeometry( axl, sax, sax );
		var axgeometryY = new THREE.BoxGeometry( sax, axl, sax );
		var axgeometryZ = new THREE.BoxGeometry( sax, sax, axl );
		
		boxMesh = new THREE.Mesh(axgeometryX);
		boxMesh.updateMatrix(); // as needed
		axgeometry.merge(boxMesh.geometry, boxMesh.matrix);
		
		boxMesh = new THREE.Mesh(axgeometryY);
		boxMesh.updateMatrix(); // as needed
		axgeometry.merge(boxMesh.geometry, boxMesh.matrix);
		
		boxMesh = new THREE.Mesh(axgeometryZ);
		boxMesh.updateMatrix(); // as needed
		axgeometry.merge(boxMesh.geometry, boxMesh.matrix);
		
		// using one material for all faces means alter one face, alter them all
		var axmaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x0000ff } );
		
		//alert( "test" );
		var axmesh = new THREE.Mesh( axgeometry, axmaterial );
		axmesh.position.set( 0, 0, 0 );
		scene.add( axmesh );
			
		/*******/


		function init() {

			container = document.createElement( 'div' );
			document.body.appendChild( container );

			var info = document.createElement( 'div' );
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'PowerBlocks';
			container.appendChild( info );

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 0, 10, 100 );
			scene.add( camera );

			var light = new THREE.PointLight( 0xffffff, 0.8 );
			light.position.set( 50, 100, 50 ); // ??? made up
			scene.add( light ); /* camera.add(…)? */
			
			var amlight = new THREE.AmbientLight( 0x404040 ); // soft white light
			scene.add( amlight );

			group = new THREE.Group();
			group.position.y = 0; // why not 0? (was 50)
			scene.add( group );
			
			loadTexture( kTextureURL ); // index 0
			
			for ( var i = 1; i <= 20; i++ )
				loadTexture( "textures/block" + i + ".jpg" );
			
			var testBlock = new blockClass( 0, 0, 0, null, null );
			testBlock.remove = function () { console.log( "I won't be removed!" ); };
			
			var secondBlock = new blockClass( 1, 1, 0 );

			raycaster = new THREE.Raycaster();

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );
			
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			//

			window.addEventListener( 'resize', onWindowResize, false );
			window.addEventListener( 'keydown', onKeyDown, false );
			window.addEventListener( 'keyup', onKeyUp, false );
			
			window.addEventListener( 'contextmenu', function (e) { e.preventDefault(); } );

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		//
		
		var faceMap = [];
		
		faceMap[ 11 ] = new THREE.Vector3( 0, 0, -1 );
		faceMap[ 10 ] = faceMap[ 11 ];
		faceMap[ 9 ] = new THREE.Vector3( 0, 0, 1 );
		faceMap[ 8 ] = faceMap[ 9 ];
		faceMap[ 7 ] = new THREE.Vector3( 0, -1, 0 );
		faceMap[ 6 ] = faceMap[ 7 ];
		faceMap[ 5 ] = new THREE.Vector3( 0, 1, 0 );
		faceMap[ 4 ] = faceMap[ 5 ];
		faceMap[ 3 ] = new THREE.Vector3( -1, 0, 0 );
		faceMap[ 2 ] = faceMap[ 3 ];
		faceMap[ 1 ] = new THREE.Vector3( 1, 0, 0 );
		faceMap[ 0 ] = faceMap[ 1 ];

		function onDocumentMouseDown( event ) {

			event.preventDefault();
			
			mouseDown = true;

			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener( 'mouseout', onDocumentMouseOut, false );

			mouseXOnMouseDown = event.clientX - windowHalfX;
			targetRotationOnMouseDown = camera.rotation.y;
			
			mouseYOnMouseDown = event.clientY - windowHalfY;
			targetXRotationOnMouseDown = camera.rotation.x;
			
			if ( INTERSECTED )
			{
				console.log( objectUnderMouse );
				if ( event.button == 0 && event.altKey )
				{
					INTERSECTED.object.owner.remove();
				}
				else if ( event.button == 0 && event.shiftKey )
				{
					;
				}
				else if ( event.button == 0 )
				{
					INTERSECTED.object.owner.action();
				}
				else if ( event.button == 2 )
				{
					console.log( INTERSECTED.object );
					console.log( faceMap[ INTERSECTED.faceIndex ] );
					
					console.log( "first", INTERSECTED.object.owner.bposition );
					var newpos = new THREE.Vector3();
					newpos.copy( INTERSECTED.object.owner.bposition );
					console.log( "copy", newpos );
					newpos.add( faceMap[ INTERSECTED.faceIndex ] );
					
					console.log( newpos );
					
					new blockClass( newpos.x, newpos.y, newpos.z );
				}
			}
			
		}
		
		function setIntersection()
		{
			// find intersections

			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( group.children );
			
			if ( intersects.length > 0 ) {

				if ( !INTERSECTED ||
						INTERSECTED.object != intersects[ 0 ].object ||
						INTERSECTED.faceIndex != intersects[ 0 ].faceIndex )
				{

					if ( INTERSECTED )
						INTERSECTED.object.owner.highlight = false;
						//INTERSECTED.object.material.wireframe = false;
						// INTERSECTED.object.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = intersects[ 0 ];
					
					/*INTERSECTED.currentHex = INTERSECTED.object.material.emissive.getHex();
					INTERSECTED.object.material.emissive.setHex( 0xff0000 );*/
					
					INTERSECTED.object.owner.highlight = true;
					//INTERSECTED.object.material.wireframe = true;
					
					objectUnderMouse = INTERSECTED.object.owner;
				}

			} else {

				if ( INTERSECTED )
					INTERSECTED.object.owner.highlight = false;
					//INTERSECTED.object.material.wireframe = false;
					// INTERSECTED.object.material.emissive.setHex( INTERSECTED.currentHex );

				INTERSECTED = null;
				objectUnderMouse = null;

			}
		}

		function onDocumentMouseMove( event ) {

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			if ( mouseDown )
			{
				camera.rotation.order = 'YXZ';
				
				mouseY = event.clientY - windowHalfY;
				mouseVX = -( mouseY - mouseYOnMouseDown ) * 0.0001;
				
				mouseX = event.clientX - windowHalfX;
				mouseVY = -( mouseX - mouseXOnMouseDown ) * 0.0001;
			}

		}

		function onDocumentMouseUp( event ) {
			
			mouseDown = false;

			//document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			mouseVX = mouseVY = 0;

		}

		function onDocumentMouseOut( event ) {
			
			mouseDown = false;

			//document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentTouchStart( event ) {

			if ( event.touches.length == 1 ) {

				event.preventDefault();

				mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

		}

		function onDocumentTouchMove( event ) {

			if ( event.touches.length == 1 ) {

				event.preventDefault();

				mouseX = event.touches[ 0 ].pageX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

			}

		}

		function onKeyDown( event )
		{
			keysDown[ event.keyCode ] = true;
		}

		function onKeyUp( event )
		{
			keysDown[ event.keyCode ] = undefined;
		}
		//

		function animate() {

			requestAnimationFrame( animate );

			camera.rotation.x += mouseVX;
			camera.rotation.y += mouseVY;
				
			if ( keysDown[65] ) // a = left
			{
				camera.position.set( camera.position.x - 1 * Math.sin( camera.rotation.y + Math.PI / 2 ), 
										camera.position.y,
										camera.position.z - 1 * Math.cos( camera.rotation.y + Math.PI / 2 ) );
			}
			if ( keysDown[68] ) // d = right
			{
				camera.position.set( camera.position.x + 1 * Math.sin( camera.rotation.y + Math.PI / 2 ), 
										camera.position.y,
										camera.position.z + 1 * Math.cos( camera.rotation.y + Math.PI / 2 ) );
			}
			if ( keysDown[83] ) // s = back
			{
				camera.position.set( camera.position.x + 1 * Math.sin( camera.rotation.y ), 
										camera.position.y,
										camera.position.z + 1 * Math.cos( camera.rotation.y ) );
			}
			if ( keysDown[87] ) // w = forward
			{
				camera.position.set( camera.position.x - 1 * Math.sin( camera.rotation.y ), 
										camera.position.y,
										camera.position.z - 1 * Math.cos( camera.rotation.y ) );
			}
			if ( keysDown[81] ) // q = up
			{
				camera.position.set( camera.position.x, 
										camera.position.y + 1,
										camera.position.z );
			}
			if ( keysDown[69] ) // e = down
			{
				camera.position.set( camera.position.x, 
										camera.position.y - 1,
										camera.position.z );
			}

			// uncomment later
			if ( gPlaying )
				physicsCallback();
			render();
			stats.update();

		}

		function render() {

			//group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
			
			setIntersection();
							
			renderer.render( scene, camera );

		}
		
		/////
		
		function placeBlock( x, y, z, textureID )
		{
			var otid = currentTextureID;
			if ( textureID )
				currentTextureID = textureID;
			new blockClass( x, y, z );
			currentTextureID = otid;
		}
		
		///////

	</script>

<div id="help-div">
		
	<div id="help-nav">
		<div class="help-type-btn" id="help-desktop-btn">Desktop</div>
	
		<div class="help-type-btn" id="help-close-btn">Close Help</div>
	</div>

	<div id="help-desktop-div">

		<p>User w/a/s/d to move, click and drag the mouse to turn, and q/e to go up, down.</p>
		
		<p>Opt-Click (Alt-Click) to remove blocks. Ctrl- or Right-Click to add blocks. Note that one block is un-removable.</p>
		
		<p>There is also a placeBlock function, designed to be easily called from the console. makePhysTest() will generate a block that responds to simple physics.</p>

	</div>

	</div>
	
	<div id="help-btn">?</div>

	<script>

var helpCloseBtn = document.querySelector( "#help-close-btn" );
helpCloseBtn.addEventListener( 'click',
function ()
{
	document.querySelector( "#help-div" ).style.display = "none";
} );

var helpDiv = document.querySelector( "#help-div" );

var helpbtn = document.querySelector( "#help-btn" );
helpbtn.addEventListener( 'click',
function ()
{
	helpDiv.style.display = "block";
} );

</script>
	
</body>

</html>