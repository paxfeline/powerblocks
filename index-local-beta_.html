<!DOCTYPE html>
<html lang="en"><head>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<title>PowerBlocks</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	
	<script src="util.js"></script>

	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>
<body>

	<script src="THREE/three.js"></script>
	<script src="THREE/stats.js"></script>
	
	<script>
			
	var kBlockSize = 10;
	
	
	
		function blockClass( x, y, z, textureIndex, guts )
		{
			this.aPirate = false;
			
			var ox = x;
			var oy = y;
			var oz = z;
			
			var blockLoc = [x, y, z].toString(); //[ ox, oy, oz ].toString();
			
			//console.log( "placing block at ", blockLoc );
			
			rootBlock.blocks[ blockLoc ] = this;
			
			//console.log( "world: ", rootBlock.blocks );
			
			this.bposition = new THREE.Vector3( x, y, z );
			
			this.positionString = blockLoc;
			
			x *= kBlockSize;
			y *= kBlockSize;
			z *= kBlockSize;

			// flat shape with texture
			// note: default UVs generated by ShapeGemoetry are simply the x- and y-coordinates of the vertices

			var geometry = new THREE.BoxGeometry( kBlockSize, kBlockSize, kBlockSize );
			
			//geometry.translate( kBlockSize / 2, kBlockSize / 2 , kBlockSize / 2 );
			
			if ( !textureIndex ) textureIndex = currentTextureID;
			this.textureIndex = textureIndex;
			var texture = textures[ textureIndex ];
			
			// using one material for all faces means alter one face, alter them all
			this.material = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, map: texture } );
			
			//alert( "test" );
			var cmesh = new THREE.Mesh( geometry, this.material );
			this.mesh = cmesh;
			this.mesh.owner = this;
			cmesh.position.set( x, y, z );
			group.add( cmesh );
			//alert( "test out" );
			
			for ( var i in guts )
			{
				console.log( "add guts ", i, guts[i] );
				var g = "(" + guts[i] + ")";
				console.log( g  );
				this[i] = eval( g );
			}
			
			Object.defineProperty( this, "getFunctions",
				{
					enumerable: false,
					value: 
						function ()
						{
							var r = {};
							for ( var i in this )
							{
								if ( this[i] instanceof Function )
									r[i] = this[i].toString();
							}
							return r;
						}
					} );
			
			Object.defineProperty( this, "texture",
				{
					enumerable: true,
					get: 
						function ()
						{
							return this.textureIndex;
						},
					set:
						function (v)
						{
							this.material.map = textures[v];
							this.textureIndex = v;
							return v;
						}
					} );
					
			
			
			// using one material for all faces means alter one face, alter them all
			this.Hmaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0xff0000, wireframe: true, wireframeLinewidth: 5 } );
			
			var hScaleFactor = 1;
			var nSize = kBlockSize * hScaleFactor;
			this.Hgeometry = new THREE.BoxGeometry( nSize, nSize, nSize );
			this.highlightMesh = new THREE.Mesh( this.Hgeometry, this.Hmaterial );
			this.highlightMesh.position.set( x, y, z );
			
			Object.defineProperty( this, "highlight",
				{
					enumerable: true,
					get: 
						function ()
						{
							return this.highlightVal;
						},
					set:
						function (v)
						{
							if ( v )
								scene.add( this.highlightMesh );
							else
								scene.remove( this.highlightMesh );
							
							this.highlightVal = v;
						}
					} );
		}
		blockClass.prototype.remove =
			function ()
			{
				rootBlock.blocks[ this.positionString ] = null;
				group.remove( this.mesh );
			};
		blockClass.prototype.action =
			function ()
			{
				console.log( "lights! camera! action!" );
			};
		blockClass.prototype.move =
			function ( x, y, z )
			{
				//console.log( "move1", this.mesh.position.x, this.mesh.position.y, this.mesh.position.z );
				this.mesh.position.x -= -Number(x);
				this.mesh.position.y -= -Number(y);
				this.mesh.position.z -= -Number(z);
				
				this.highlightMesh.position.x -= -Number(x);
				this.highlightMesh.position.y -= -Number(y);
				this.highlightMesh.position.z -= -Number(z);
				//console.log( "move2", this.mesh.position.x, this.mesh.position.y, this.mesh.position.z );
				
				var newPos = [ Math.round( this.mesh.position.x / 10 ),
								Math.round( this.mesh.position.y / 10 ),
								Math.round( this.mesh.position.z / 10 ) ].toString();
				
				if ( newPos != this.positionString )
				{
					//console.log( "delta", newPos, this.positionString );
					rootBlock.blocks[ this.positionString ] = null;
					this.positionString = newPos;
					rootBlock.blocks[ newPos ] = this;
				}
			};
		blockClass.prototype.collision =
			function ( obj )
			{
				console.log( "collision with" );
				console.log( obj );
				this.Vy = 0;
			};
	
	/** physics **/
	
	var physObjs = [];
	var lastTime;
	
	var kFrameRate = 30;
	var kMS = 1000 / kFrameRate;
	
	var kMaxSteps = 2;
	
	var kGravity = -25;
	
	function physicsCallback()
	{
		if ( ! lastTime ) { lastTime = performance.now(); return; }
		
		var now = performance.now();
		
		var mult = Math.floor( (now - lastTime) / kMS );
		
		mult = Math.min( mult, kMaxSteps );
		
		var tdelta = (mult * kMS) / 1000;
		
		var tleft = tdelta;
		
		console.log( mult, tdelta );
		
		lastTime = now - ((now - lastTime) - (mult * kMS));
		
		/*	calculate trajectory
			divide by kBoxSize
			sort / find max/min
			loop from ceil(min) to floor(max) */
		
		var axes = [ "x", "y", "z" ];
		var oAxes = [ [ "y", "z" ], [ "x", "z" ], [ "x", "y" ] ];
		
		if ( physObjs.length > 0 )
		{
			var cobj = physObjs[0].owner;
			
			var p0 = cobj.mesh.position.clone();
			var cp = p0.clone();
			
			//console.log( "p0", p0 );
			
			var times = [];
			
			/* move objects */
			
			cobj.Vy = (cobj.Vy ? cobj.Vy : 0) + (kGravity * tdelta);
			
			cp.y += (cobj.Vy * tdelta);
			
			//console.log( "cp", cp );
			
			// calculate X columns
			
			if ( cp.x > Math.floor( cp.x ) )
			{
				var X = [ Math.round( cp.x ) / 10,
							Math.round( cp.x ) / 10 + 1 ];
			}
			else if ( cp.x < Math.floor( cp.x ) )
			{
				var X = [ Math.round( cp.x ) / 10,
							Math.round( cp.x ) / 10 - 1 ];
			}
			else
				var X = [ Math.round( cp.x ) / 10 ];
			
			// calc Z columns
			
			if ( cp.z > Math.floor( cp.z ) )
			{
				var Z = [ Math.round( cp.z ) / 10,
							Math.round( cp.z ) / 10 + 1 ];
			}
			else if ( cp.z < Math.floor( cp.z ) )
			{
				var Z = [ Math.round( cp.z ) / 10,
							Math.round( cp.z ) / 10 - 1 ];
			}
			else
				var Z = [ Math.round( cp.z ) / 10 ];
				
			// calc Y collisions
			
			console.log( "y", Math.floor( p0.y / 10 ), Math.ceil( cp.y / 10 ) );
			
			for ( var xi = 0; xi < X.length; xi++ )
			{
				for ( var zi = 0; zi < Z.length; zi++ )
				{
					for ( var yi = Math.floor( p0.y / 10 );
							yi >= Math.ceil( cp.y / 10 );
							yi-- )
					{
						console.log( "xi", xi, "yi", yi - 1, "zi", zi );
						
						var colblock = rootBlock.blocks[ [ xi, yi - 1, zi ].toString() ];
						
						console.log( colblock );
						
						if ( colblock )
						{
							var t = (yi * 10 - p0.y) / cobj.Vy;
							times.push( { time: t, axes: ["y"], target: colblock } );
						}
					}
				}
			}
			
			times.sort(
				function ( a, b )
				{
					return a.time - b.time;
				} );
				
			while ( times.length > 0 )
			{
				cobj.move( 0, cobj.Vy * times[0].time, 0 );
				cobj.collision( times[0].target );
				console.log( "proc", times[0] );
				tleft -= times[0].time;
				times.shift();
			}
			
			cobj.move( 0, cobj.Vy * tleft, 0 );
			
			console.log( p0.y, cobj.mesh.position.y );
		}
	}
	
	function makePhysTest()
	{
		var geometry = new THREE.BoxGeometry( kBlockSize, kBlockSize, kBlockSize );
		
		// using one material for all faces means alter one face, alter them all
		var material = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x00ff00 } );
		
		var cmesh = (new blockClass( 0, 3, 0 )).mesh;
		cmesh.material = material;
		
		//console.log( cmesh.owner );
		
		globe = cmesh.owner;
		
		cmesh.owner.move( 2.5, 0, 0 );
		
		physObjs.push( cmesh );
	}
	
	/*************/
	
	
		
		var keysDown = {};
		
		function worldBlockClass ( x, y )
		{
			this.x = x;
			this.y = y;
			
			this.blocks = {};
		}

		var container, stats;

		var camera, scene, raycaster, renderer;

		var group;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;
		
		var targetXRotation = 0;
		var targetXRotationOnMouseDown = 0;

		var mouseDown = false;
		var mouseX = 0;
		var mouseXOnMouseDown = 0;
		var mouseY = 0;
		
		var mouseVY = 0, mouseVX = 0;
		
		var mouse = new THREE.Vector2(), INTERSECTED;
		var objectUnderMouse;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		
		var textures = [];
		
		var kTextureURL = "textures/block.jpg";
		
		var currentTextureID = 0;
		
		function loadTexture( textureURL, name )
		{
			console.log( "load texture", textureURL );
			
			var pxtexture;
			
			var pat = /^https?:\/\//i;
			if ( pat.test(textureURL) )
			{
				console.log( "abs url", "getfile.php?url=" + encodeURIComponent( textureURL ) );
				
				var pxcan = document.createElement( "canvas" );
				pxcan.width = 256;
				pxcan.height = 256;
				var pxctx = pxcan.getContext( "2d" );
				var pximg = new Image();
				pximg.onload =
					function ()
					{
						pxctx.drawImage( pximg, 0, 0, 256, 256 );
					
						pxtexture = new THREE.Texture( pxcan );
						pxtexture.needsUpdate = true;
			
						if ( name )
							textures[ name ] = pxtexture;
						else
							textures.push( pxtexture );
					};
				pximg.src = "getfile.php?url=" + encodeURIComponent( textureURL );
			}
			else
			{
				pxtexture = THREE.ImageUtils.loadTexture( textureURL, null,
					function (x) { /*console.log( "texture onLoad", x )*/; },
					function (x) { console.log( "texture load error", x ); } );
			
				if ( name )
					textures[ name ] = pxtexture;
				else
					textures.push( pxtexture );
			}
		}
		
		var rootBlock = new worldBlockClass( 0, 0 );
		
		function getBlock( x, y, z ) { return rootBlock.blocks[ [ x, y, z ].toSrting() ]; }

		init();
		animate();
	
		makePhysTest();
		
		/*******/
		
		var sax = 1;
		var axl = 1000;
		
		var axgeometry = new THREE.Geometry();
		
		var axgeometryX = new THREE.BoxGeometry( axl, sax, sax );
		var axgeometryY = new THREE.BoxGeometry( sax, axl, sax );
		var axgeometryZ = new THREE.BoxGeometry( sax, sax, axl );
		
		boxMesh = new THREE.Mesh(axgeometryX);
		boxMesh.updateMatrix(); // as needed
		axgeometry.merge(boxMesh.geometry, boxMesh.matrix);
		
		boxMesh = new THREE.Mesh(axgeometryY);
		boxMesh.updateMatrix(); // as needed
		axgeometry.merge(boxMesh.geometry, boxMesh.matrix);
		
		boxMesh = new THREE.Mesh(axgeometryZ);
		boxMesh.updateMatrix(); // as needed
		axgeometry.merge(boxMesh.geometry, boxMesh.matrix);
		
		// using one material for all faces means alter one face, alter them all
		var axmaterial = new THREE.MeshPhongMaterial( { side: THREE.DoubleSide, color: 0x0000ff } );
		
		//alert( "test" );
		var axmesh = new THREE.Mesh( axgeometry, axmaterial );
		axmesh.position.set( 0, 0, 0 );
		scene.add( axmesh );
			
		/*******/


		function init() {

			container = document.createElement( 'div' );
			document.body.appendChild( container );

			var info = document.createElement( 'div' );
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = 'PowerBlocks';
			container.appendChild( info );

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 0, 10, 50 );
			scene.add( camera );

			var light = new THREE.PointLight( 0xffffff, 0.8 );
			light.position.set( 50, 100, 50 ); // ??? made up
			scene.add( light ); /* camera.add(…)? */
			
			var amlight = new THREE.AmbientLight( 0x404040 ); // soft white light
			scene.add( amlight );

			group = new THREE.Group();
			group.position.y = 0; // why not 0? (was 50)
			scene.add( group );
			
			loadTexture( kTextureURL ); // index 0
			
			for ( var i = 1; i <= 20; i++ )
				loadTexture( "textures/block" + i + ".jpg" );
			
			var testBlock = new blockClass( 0, 0, 0, null, null );
			testBlock.remove = function () { console.log( "I won't be removed!" ); };
			
			var secondBlock = new blockClass( 1, 1, 0 );

			raycaster = new THREE.Raycaster();

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			container.appendChild( renderer.domElement );

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );

			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );
			
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			//

			window.addEventListener( 'resize', onWindowResize, false );
			window.addEventListener( 'keydown', onKeyDown, false );
			window.addEventListener( 'keyup', onKeyUp, false );
			
			window.addEventListener( 'contextmenu', function (e) { e.preventDefault(); } );

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		//
		
		var faceMap = [];
		
		faceMap[ 11 ] = new THREE.Vector3( 0, 0, -1 );
		faceMap[ 10 ] = faceMap[ 11 ];
		faceMap[ 9 ] = new THREE.Vector3( 0, 0, 1 );
		faceMap[ 8 ] = faceMap[ 9 ];
		faceMap[ 7 ] = new THREE.Vector3( 0, -1, 0 );
		faceMap[ 6 ] = faceMap[ 7 ];
		faceMap[ 5 ] = new THREE.Vector3( 0, 1, 0 );
		faceMap[ 4 ] = faceMap[ 5 ];
		faceMap[ 3 ] = new THREE.Vector3( -1, 0, 0 );
		faceMap[ 2 ] = faceMap[ 3 ];
		faceMap[ 1 ] = new THREE.Vector3( 1, 0, 0 );
		faceMap[ 0 ] = faceMap[ 1 ];

		function onDocumentMouseDown( event ) {

			event.preventDefault();
			
			mouseDown = true;

			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener( 'mouseout', onDocumentMouseOut, false );

			mouseXOnMouseDown = event.clientX - windowHalfX;
			targetRotationOnMouseDown = camera.rotation.y;
			
			mouseYOnMouseDown = event.clientY - windowHalfY;
			targetXRotationOnMouseDown = camera.rotation.x;
			
			if ( INTERSECTED )
			{
				console.log( objectUnderMouse );
				if ( event.button == 0 && event.altKey )
				{
					INTERSECTED.object.owner.remove();
				}
				else if ( event.button == 0 && event.shiftKey )
				{
					;
				}
				else if ( event.button == 0 )
				{
					INTERSECTED.object.owner.action();
				}
				else if ( event.button == 2 )
				{
					console.log( INTERSECTED.object );
					console.log( faceMap[ INTERSECTED.faceIndex ] );
					
					console.log( "first", INTERSECTED.object.owner.bposition );
					var newpos = new THREE.Vector3();
					newpos.copy( INTERSECTED.object.owner.bposition );
					console.log( "copy", newpos );
					newpos.add( faceMap[ INTERSECTED.faceIndex ] );
					
					console.log( newpos );
					
					new blockClass( newpos.x, newpos.y, newpos.z );
				}
			}
			
		}
		
		function setIntersection()
		{
			// find intersections

			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( group.children );
			
			if ( intersects.length > 0 ) {

				if ( !INTERSECTED ||
						INTERSECTED.object != intersects[ 0 ].object ||
						INTERSECTED.faceIndex != intersects[ 0 ].faceIndex )
				{

					if ( INTERSECTED )
						INTERSECTED.object.owner.highlight = false;
						//INTERSECTED.object.material.wireframe = false;
						// INTERSECTED.object.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = intersects[ 0 ];
					
					/*INTERSECTED.currentHex = INTERSECTED.object.material.emissive.getHex();
					INTERSECTED.object.material.emissive.setHex( 0xff0000 );*/
					
					INTERSECTED.object.owner.highlight = true;
					//INTERSECTED.object.material.wireframe = true;
					
					objectUnderMouse = { object: INTERSECTED.object, faceIndex: INTERSECTED.faceIndex };
				}

			} else {

				if ( INTERSECTED )
					INTERSECTED.object.owner.highlight = false;
					//INTERSECTED.object.material.wireframe = false;
					// INTERSECTED.object.material.emissive.setHex( INTERSECTED.currentHex );

				INTERSECTED = null;
				objectUnderMouse = null;

			}
		}

		function onDocumentMouseMove( event ) {

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			if ( mouseDown )
			{
				camera.rotation.order = 'YXZ';
				
				mouseY = event.clientY - windowHalfY;
				mouseVX = -( mouseY - mouseYOnMouseDown ) * 0.0001;
				
				mouseX = event.clientX - windowHalfX;
				mouseVY = -( mouseX - mouseXOnMouseDown ) * 0.0001;
			}

		}

		function onDocumentMouseUp( event ) {
			
			mouseDown = false;

			//document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			mouseVX = mouseVY = 0;

		}

		function onDocumentMouseOut( event ) {
			
			mouseDown = false;

			//document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentTouchStart( event ) {

			if ( event.touches.length == 1 ) {

				event.preventDefault();

				mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

		}

		function onDocumentTouchMove( event ) {

			if ( event.touches.length == 1 ) {

				event.preventDefault();

				mouseX = event.touches[ 0 ].pageX - windowHalfX;
				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

			}

		}

		function onKeyDown( event )
		{
			keysDown[ event.keyCode ] = true;
		}

		function onKeyUp( event )
		{
			keysDown[ event.keyCode ] = undefined;
		}
		//

		function animate() {

			requestAnimationFrame( animate );

			camera.rotation.x += mouseVX;
			camera.rotation.y += mouseVY;
				
			if ( keysDown[65] ) // a = left
			{
				camera.position.set( camera.position.x - 1 * Math.sin( camera.rotation.y + Math.PI / 2 ), 
										camera.position.y,
										camera.position.z - 1 * Math.cos( camera.rotation.y + Math.PI / 2 ) );
			}
			if ( keysDown[68] ) // d = right
			{
				camera.position.set( camera.position.x + 1 * Math.sin( camera.rotation.y + Math.PI / 2 ), 
										camera.position.y,
										camera.position.z + 1 * Math.cos( camera.rotation.y + Math.PI / 2 ) );
			}
			if ( keysDown[83] ) // s = back
			{
				camera.position.set( camera.position.x + 1 * Math.sin( camera.rotation.y ), 
										camera.position.y,
										camera.position.z + 1 * Math.cos( camera.rotation.y ) );
			}
			if ( keysDown[87] ) // w = forward
			{
				camera.position.set( camera.position.x - 1 * Math.sin( camera.rotation.y ), 
										camera.position.y,
										camera.position.z - 1 * Math.cos( camera.rotation.y ) );
			}
			if ( keysDown[81] ) // q = up
			{
				camera.position.set( camera.position.x, 
										camera.position.y + 1,
										camera.position.z );
			}
			if ( keysDown[69] ) // e = down
			{
				camera.position.set( camera.position.x, 
										camera.position.y - 1,
										camera.position.z );
			}

			// uncomment later
			physicsCallback();
			render();
			stats.update();

		}

		function render() {

			//group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
			
			setIntersection();
							
			renderer.render( scene, camera );

		}
		
		/////
		
		function placeBlock( x, y, z, textureID )
		{
			var otid = currentTextureID;
			if ( textureID )
				currentTextureID = textureID;
			new blockClass( x, y, z );
			currentTextureID = otid;
		}
		
		///////

	</script>
	
	



</body></html>